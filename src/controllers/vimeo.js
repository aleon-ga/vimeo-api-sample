const fetch = require('node-fetch');
const { GetObjectCommand, PutObjectCommand } = require('@aws-sdk/client-s3');
const { client } = require('../config');
const { BUCKET_NAME, VIMEO_API_BASE_URL } = require('../constants');
const { extractRateLimitHeaders, setCaptionsLanguage } = require('../helpers');
const { VIMEO_PERSONAL_ACCESS_TOKEN } = process.env;

const getAutoGeneratedCaptions = async (req, res) => {

    const failures = [], uploaded = [];

    let rateLimitHeaders;

    try {

        const videos = req.body.videos || [];

        if (videos.length === 0) {

            throw new Error('No video IDs found.');

        };

        await Promise.all(videos.map(async (id, index) => {

            let response;

            const url = `${VIMEO_API_BASE_URL}/videos/${id}/texttracks`;

            const options = {
                headers: {
                    Authorization: `Bearer ${VIMEO_PERSONAL_ACCESS_TOKEN}`,
                    Accept: 'application/vnd.vimeo.*+json;version=3.4'
                }
            };

            //TODO: Step 1: get all the text tracks of a video.
            response = await fetch(url, options);

            if (!response.ok) {

                console.error(`Failed to retrieve the text tracks of the video ${id}`);

                failures.push(id);

                return;

            };

            /**************************/
            /*** RATE LIMIT HEADERS ***/
            /**************************/

            // The last iteration
            if (index === videos.length - 1) rateLimitHeaders = extractRateLimitHeaders(response.headers); // From Vimeo

            /**************************/
            /**************************/
            /**************************/

            const { data } = await response.json();

            if (data.length === 0) {

                console.error(`The video ${id} has no text tracks.`);

                failures.push(id);

                return;

            };

            const autoGeneratedCaptions = data.find(textTrack => textTrack.type === 'captions' && textTrack.name === 'auto_generated_captions.vtt');

            const { language: unformattedCaptionsLang, link: captionsDownloadUrl, name: captionsFileName } = autoGeneratedCaptions;

            //TODO: Step 2: download the auto generated captions.
            response = await fetch(captionsDownloadUrl, options);

            if (!response.ok) {

                console.error(`Failed to download the auto generated captions file of the video ${id}`);

                failures.push(id);

                return;

            };

            const captionsFileBuffer = await response.buffer(); // Ensures that the entire content of the file is read and stored in a buffer before uploading it to S3.

            const captionsLang = setCaptionsLanguage(unformattedCaptionsLang);

            if (!captionsLang) {

                console.error(`Failed to set captions language of the video ${id}`); // Because the specified language for captions was not found.

                failures.push(id);

                return;

            };

            const params = {
                Bucket: BUCKET_NAME,
                Key: `in/${id}/${captionsLang}_${captionsFileName}`, // The video ID serves as the folder name, while the combination of the captions language and captions name constitutes the file name.
                Body: captionsFileBuffer // The content of the file.
            };

            const putCommand = new PutObjectCommand(params);

            // TODO: Step 3: upload the auto generated captions to S3.
            response = await client.send(putCommand);

            response['$metadata']?.httpStatusCode === 200 ? uploaded.push(id) : failures.push(id);

        }));

        if (uploaded.length > 0 && failures.length === 0) {

            res.status(200).json({
                message: 'All videos have been successfully uploaded to S3.',
                apiRequestsInfo: rateLimitHeaders
            });

        } else if (uploaded.length > 0 && failures.length > 0) {

            res.status(200).json({
                uploaded: uploaded.join(', '),
                failures: failures.join(', '),
                apiRequestsInfo: rateLimitHeaders
            });

        } else if (uploaded.length === 0 && failures.length > 0) {

            throw new Error(`Failed to upload all the videos.`);

        };

    } catch (error) {

        console.error(error);

        res.status(500).json({
            message: error.message,
            apiRequestsInfo: rateLimitHeaders
        });

    };

}; //!GETAUTOGENERATEDCAPTIONS-END

const getTranslatedCaptions = async (req, res) => {

    let options, response;

    const languageCodeOptions = { english: 'es', spanish: 'es', french: 'fr', italian: 'it', portuguese: 'pt' };

    try {

        const key = 'out/911287476/spanish.vtt'; //! DINÁMICO (Lambda S3 event)

        const params = {
            Bucket: BUCKET_NAME,
            Key: key
        };

        const getCommand = new GetObjectCommand(params);

        // TODO: Step 1: get the translated captions from S3.
        response = await client.send(getCommand);

        if (response['$metadata']?.httpStatusCode !== 200) {

            throw new Error('Failed to retrieve the translated captions file.');

        };

        const date = response.Body.headers.date;

        const translatedCaptions = await response.Body.transformToString();

        const [, videoId, fileName] = key.split('/'); // out/911287476/spanish.vtt => videoId = 911287476, fileName = spanish.vtt

        const url = `${VIMEO_API_BASE_URL}/videos/${videoId}/texttracks`;
        
        const language = fileName.split('.')[0]; // spanish.vtt => language = spanish

        const languageCode = languageCodeOptions[language];

        options = {
            method: 'POST',
            body: JSON.stringify({
                type: 'captions',
                language: languageCode,
                name: language
            }),
            headers: {
                Authorization: `Bearer ${VIMEO_PERSONAL_ACCESS_TOKEN}`, //! .env
                'Content-Type': 'application/json',
                Accept: 'application/vnd.vimeo.*+json;version=3.4'
            }
        };

        /**
         * TODO: Step 2: get the upload link for the text track (captions).
         * To get the upload link for the text track, you must first create the text track's resource, which is like a container to hold the track.
         */
        response = await fetch(url, options);

        if (!response.ok) {

            throw new Error("Failed to create the text track's resource.");

        };

        const { link } = await response.json();

        options = {
            method: 'PUT',
            body: translatedCaptions,
            headers: { Accept: 'application/vnd.vimeo.*+json;version=3.4' }
        };

        /**
         * TODO: Step 3: upload the text track (captions).
         * To upload the text track, take the value of the link field from step 2, and make a `PUT` request to this location.
         */
        response = await fetch(link, options);

        if (!response.ok) {

            throw new Error('Failed to upload the text track.');

        };

        res.status(response.status).json({ date, message: 'Text track upload successful.' }); //! E.g., change to a log in Lambda

        return;

    } catch (error) {

        console.error(error);

        res.status(500).json(error); //! E.g., change to a log in Lambda

        return;

    };

}; //!GETTRANSLATEDCAPTIONS-END


module.exports = {
    getAutoGeneratedCaptions,
    getTranslatedCaptions
};